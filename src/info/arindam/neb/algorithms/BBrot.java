package info.arindam.neb.algorithms;

import info.arindam.neb.Engine;
import java.awt.Dimension;
import java.util.LinkedHashMap;
import java.util.concurrent.ThreadLocalRandom;

/**
 *
 * @author Arindam Biswas <arindam dot b at eml dot cc>
 */
public class BBrot implements Algorithm {

    public static final LinkedHashMap<String, String> DEFAULT_PARAMETERS;
    private static final int TASK_SAMPLE_SIZE = 100;
    private final int iterationLimit, colourShift, sampleSize, degree;
    private final double minX, minY, rangeX, rangeY, escapeDistance;

    static {
        DEFAULT_PARAMETERS = new LinkedHashMap<>();
        DEFAULT_PARAMETERS.put("min_x", "-2.0");
        DEFAULT_PARAMETERS.put("min_y", "-1.5");
        DEFAULT_PARAMETERS.put("range_x", "3.0");
        DEFAULT_PARAMETERS.put("range_y", "3.0");
        DEFAULT_PARAMETERS.put("sample_size", "10000000");
        DEFAULT_PARAMETERS.put("iteration_limit", "100");
        DEFAULT_PARAMETERS.put("escape_distance", "2.0");
        DEFAULT_PARAMETERS.put("colour", "blue");
        DEFAULT_PARAMETERS.put("degree", "2");
        DEFAULT_PARAMETERS.put("--", "--");
    }

    public BBrot(LinkedHashMap<String, String> parameters) {
        minX = Double.parseDouble(parameters.get("min_x"));
        minY = Double.parseDouble(parameters.get("min_y"));
        rangeX = Double.parseDouble(parameters.get("range_x"));
        rangeY = Double.parseDouble(parameters.get("range_y"));
        iterationLimit = Integer.parseInt(parameters.get("iteration_limit"));
        sampleSize = Integer.parseInt(parameters.get("sample_size"));
        degree = Integer.parseInt(parameters.get("degree"));
        escapeDistance = Double.parseDouble(parameters.get("escape_distance"));
        String colour = (String) parameters.get("colour");
        switch (colour) {
            case "red":
                colourShift = 16;
                break;
            case "green":
                colourShift = 8;
                break;
            default:
                colourShift = 0;
        }
    }

    @Override
    public int getNegativeMultiplier(int processorCount) {
        return 1;
    }

    @Override
    public void run(Engine.Negative negative) { // TODO: Use "advanced probabilistic techniques".
        int[][] buffer = (int[][]) negative.buffer;
        for (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {
            int j, bufferX, bufferY; // location of (zR, zI) in histogram
            double cR, cI, zR, zI, p;
            // use ThreadLocalRandom for improved performance
            cR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);
            cI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);
            // check if the sequence generated by (cR, cI) escapes
            for (j = 0; j < iterationLimit; j++) {
                for (int k = 1; k < degree; k++) {
                    p = zR;
                    zR = zR * zR - zI * zI;
                    zI = 2 * p * zI;
                }
                zR += cR;
                zI += cI;
                if (zR * zR + zI * zI > escapeDistance * escapeDistance) {
                    break;
                }
            }
            if (j == iterationLimit) { // does the sequence escape?
                continue;
            }
            zR = cR;
            zI = cI;
            for (j = 0; j < iterationLimit; j++) {
                // Is the point within the rendering region?
                if (zR >= minX && zR - minX <= rangeX && zI >= minY && zI - minY <= rangeY) {
                    bufferX = (int) (((zR - minX) / rangeX) * buffer.length);
                    bufferY = (int) (((zI - minY) / rangeY) * buffer[0].length);
                    buffer[bufferX][bufferY]++;
                }
                for (int k = 1; k < degree; k++) {
                    p = zR;
                    zR = zR * zR - zI * zI;
                    zI = 2 * p * zI;
                }
                zR += cR;
                zI += cI;
            }
        }
    }

    @Override
    public void process(Engine.Negative[] negatives, Engine.Positive positive) {
        int[][] histogram = new int[((int[][]) negatives[0].buffer).length]
                [((int[][]) negatives[0].buffer).length];
        int max = 0; // Holds the maximum of all values in the "histogram".

        for (int i = 0; i < histogram.length; i++) {
            for (int j = 0; j < histogram[0].length; j++) {
                for (Engine.Negative negative : negatives) {
                    histogram[i][j] += ((int[][]) negative.buffer)[i][j];
                }
                max = max < histogram[i][j] ? histogram[i][j] : max;
            }
        }
        for (int i = 0; i < histogram.length; i++) {
            for (int j = 0; j < histogram[0].length; j++) {
                int posIndex = positive.getWidth() * (positive.getHeight() - j - 1) + i;
                positive.buffer[posIndex] = 0xff000000 | (int) (255 * histogram[i][j]
                        / (double) max) << colourShift;
            }
        }
    }

    @Override
    public String toString() {
        return "bbrot";
    }

    @Override
    public int getTaskIterationGoal(int processorCount) {
        return sampleSize / (TASK_SAMPLE_SIZE * processorCount);
    }

    @Override
    public int[][] createNegativeBuffer(Dimension positiveSize) {
        return new int[positiveSize.width][positiveSize.height];
    }
}
