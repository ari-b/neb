package info.arindam.neb.algorithms;

import info.arindam.neb.Engine;
import java.util.HashMap;
import java.util.concurrent.ThreadLocalRandom;

/**
 *
 * @author Arindam Biswas <arindam dot b at eml dot cc>
 */
public class Green1 extends Algorithm {

    private final int iterationLimit, colourShift;
    private final double minX, minY, rangeX, rangeY, escapeDistance;

    public Green1(HashMap<String, Object> parameters) {
        minX = (double) parameters.get("min_x");
        minY = (double) parameters.get("min_y");
        rangeX = (double) parameters.get("range_x");
        rangeY = (double) parameters.get("range_y");
        iterationLimit = (int) parameters.get("iteration_limit");
        escapeDistance = (double) parameters.get("escape_distance");
        String colour = (String) parameters.get("colour");
        switch (colour) {
            case "red":
                colourShift = 16;
                break;
            case "green":
                colourShift = 8;
                break;
            default:
                colourShift = 0;
        }
    }

    @Override
    public int getNegativeMultiplier() {
        return 1;
    }

    @Override
    public void run(Engine.Negative negative) { // TODO: Use "advanced probabilistic techniques".
        int[][] buffer = negative.buffer;
        int sampleSize = (int) negative.data.get("sample_size");
        for (int i = 1; i <= sampleSize; i++) {
            int j, bufferX, bufferY; // location of (zR, zI) in histogram
            double cR, cI, zR, zI, p;
            // use ThreadLocalRandom for improved performance
            cR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);
            cI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);
            // check if the sequence generated by (cR, cI) escapes
            for (j = 0; j < iterationLimit; j++) {
                p = zR;
                zR = zR * zR - zI * zI + cR;
                zI = 2 * p * zI + cI;
                if (zR * zR + zI * zI > escapeDistance * escapeDistance) {
                    break;
                }
            }
            if (j == iterationLimit) { // does the sequence escape?
                continue;
            }
            zR = cR;
            zI = cI;
            for (j = 0; j < iterationLimit; j++) {
                // is the point within the rendering region?
                if (zR >= minX && zR - minX <= rangeX && zI >= minY && zI - minY <= rangeY) {
                    bufferX = (int) (((zR - minX) / rangeX) * buffer.length);
                    bufferY = (int) (((zI - minY) / rangeY) * buffer[0].length);
                    buffer[bufferX][bufferY]++;
                }
                p = zR;
                zR = zR * zR - zI * zI + cR;
                zI = 2 * p * zI + cI;
            }
        }
    }

    @Override
    public void process(Engine.Negative[] negatives, Engine.Positive positive) {
        int[][] histogram = new int[negatives[0].buffer.length][negatives[0].buffer[0].length];
        int max = 0; // holds the maximum of all values in the "histogram"

        for (int i = 0; i < histogram.length; i++) {
            for (int j = 0; j < histogram[0].length; j++) {
                for (Engine.Negative negative : negatives) {
                    histogram[i][j] += negative.buffer[i][j];
                }
                max = max < histogram[i][j] ? histogram[i][j] : max;
            }
        }
        for (int i = 0; i < histogram.length; i++) {
            for (int j = 0; j < histogram[0].length; j++) {
                int posIndex = positive.getWidth() * (positive.getHeight() - j - 1) + i;
                positive.buffer[posIndex] = 0xff000000 | (int) (255 * histogram[i][j]
                        / (double) max) << colourShift;
            }
        }
    }

    public static HashMap<String, Object> getDefaultParameters() {
        HashMap<String, Object> parameters = new HashMap();
        parameters.put("min_x", -2.0);
        parameters.put("min_y", -1.5);
        parameters.put("range_x", 3.0);
        parameters.put("range_y", 3.0);
        parameters.put("sample_size", 10000000);
        parameters.put("iteration_limit", 100);
        parameters.put("escape_distance", 2.0);
        parameters.put("colour", "blue");
        parameters.put("degree", 2);
        return parameters;
    }
}
